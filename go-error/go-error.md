# Обработка ошибок на Go - не ок
![img](GoError.png)
Я довольно долго хейтил Go, за его неприглядный синтаксис. И, как это обычно и бывает, совсем скоро начну на нем работать. Вся статья - одно большое ИМХО на обработку ошибок в Go. Я не большой специалист в этом языке, просто мне не очень нравится подход, который используется в настоящий момент.

Статья не претендует на звание "полезной" и даже "умной". Читайте её как чьё-то мнение, на определенные особенности языка.

## Одно большое ИМХО
Когда пишешь код на Go, ощущение, будто ты пишешь один и тот же код, ведь каждый вызов функции сопровождает эта странная обработка ошибки `err != nil`. Если раньше, до дженериков, это можно было оправдывать, то сейчас подобное тянется скорее как легаси. И ладно если бы это критиковалось, но ведь Go-внари (программисты использующие язык программирования Go) яро отстаивают подобное, не видя проблем и даже называя это "фичей" языка. (Тогда фича JS - прокачка экстрасенсорных способностей, от попыток угадать что у тебя в переменной `test2`)

Мало того, что контракт *если `err == nil`, то ошибки нет* довольно жидкий, так ещё и постоянно проверять результат на ошибки при вызове лишь усложняет логику обработки этих ошибок. У нас нет особо вариантов, кроме как прервать выполнение функции и отдать ошибку.

По началу я думал, что Go-внари получают ЗП построчно, потому так отстаивают подобную обработку, что бы всё объяснило. Но им платят как и всем, из чего следует вывод - Go-внари любят страдать.

Я понимаю, что "ошибка это значение", но думаю что для работы с этими значениями, нужно не просто избавиться от ошибки, а гарантировать обработку ошибки и дать возможность создавать более полезную логику их обработки.

## ИМХО выраженное через код
Так как мне придется пользоваться данной технологией, я решил сделать для себя, в качестве эксперимента, библиотеку, которая бы позволяла изменить подход к обработке ошибок. Потратил на это около часа.

Так как мне нравится обработка ошибок в Rust, я решил позаимствовать подход, создав структуру, которая имеет два поля - ошибку и значение. Сразу добавил методы взаимодействия с этой структурой и получил вполне терпимый результат, который смог добавить в свой проект. [Ссылка на библиотеку.](https://github.com/LimitR/goresult)

Всё что я решил сделать, так это создать обертку вокруг результата вызова функции, чтоб работать с одной структурой `Result[T]`, которая имеет значение, и/или ошибку. Такой подход используется в Rust, но вместо struct используется enum. Но работаем с тем что имеем.

Вместо того, чтоб каждый раз провериять ошибку:

```go
file, err := os.Open("/path/to/file.txt")
if err != nil {
    log.Fatal(err)
}
defer file.Close()
```
Мы можем вызвать панику, или использовать прочую логику:

```go
file := goresult.CreateResult(os.Open("/path/to/file.txt")).Unwrap()
defer file.Close()
```
Такой подход позволяет сохранить единообразие данных, возвращаемых из функций и упростить (скорее избавить от бесконечных проверок) обработку ошибок. Ведь теперь любая функция может вернуть `Result[T]`, у которой можно вызвать нужный метод обработки, или не обрабатывать вовсе, если это не требуется в данный момент. (Т.е. отложить проверку результата, до момента использования значения)

Если нам в момент вызова возвращается ошибка, но вместо паники мы хотим изменить поведение (значение результата), то это делается самым очевидным образом:

```go
result := getResultError().UnwrapOrOn(func(res error) string {
	fmt.Println(res.Error()) // Error message
	return "default"
})
fmt.Println(result) // default
```
Или:
```go
result := getResultError().UnwrapOrElse("default")
fmt.Println(result) // default
```
Вместо:
```go
result, err := getResultError()
if err != nil {
    result = "default"
}
fmt.Println(result) // default
```

Такой подход более гибкий к обработке ошибок и позволяет создать одну обработку на всю программу, вместо бесконечного повторения одинокового кода, ещё и появляется возможность передавать в цепочку вызовов значение, валидное по сигнатуре, без обработки в момент получения.

Так как мы получаем панику, в случае если ошибка обрабатывалась "лениво" (через метод `Unwrap()` - пример), но часть данных уже лежит записалась, мы можем использовать метод `UnwrapDelay()`, который позволяет выполнить код внутри callback, до вызова паники, например для сохранения значения в базу и т.д.
```go
result := getResultError().UnwrapDelay(func(res string) {
	fmt.Println(res) // ok - value Result
	// ... Some code before the panic
	// ...
}) // panic: AAAA
```
В callback мы можем получить данные, но не вернуть его. Единственный вариант избежать паники, это вызвать функцию `recover()`, что позволит продолжить исполнение команды. (Такое я, конечно, осуждаю)

Если мы вводим возможность обработки результата вне вызываемой функции, то нужна возможность собирать эти ошибки и обрабатывать их сразу несколько.

Для этого я сделал функцию, которая позволяет получить все значения, игнорируя ошибки.
```go
c := goresult.NewResult("ok")
c2 := goresult.NewResult("ok2")
c2.AddError("Panic")
c3 := goresult.NewResult("ok3")

ch := []Result[string]{*c, *c2, *c3}

fmt.Println(goresult.CheckAll(ch)) // [ok ok3]
```
## ИМ ХОрошо и так

Сколько вы бы не пытались доказать свою дочку зрения, касаемо странного решения при проектировании языка, некоторые люди не видят причин к изменениям, ведь подобное не только вызывает стресс, так ещё и выглядит как покушение на тебя лично. Ведь как кто-то посмел усомниться в подходе, к которому я привык? Очевидно что этот человек просто глупый и хочет усложнить себе и, что самое ужасное, МНЕ жизнь.

Но я не пытаюсь убедить кого-то, что мой подход лучше. Это скорее трезвый взгляд человека, которого что-то смущает в технологии. Возможно у меня не замыленный взгляд, а что скорее всего - я просто чего-то не понял. В любом случае мне было бы очень интересно выслушать ваше мнение, а любую критику реализации, принимаю в виде пулреквестов. Всем мира, добра и `err == nil`!